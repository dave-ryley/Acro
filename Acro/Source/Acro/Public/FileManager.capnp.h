#include "Acro.h"

#pragma once

// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: FileManager.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#if CAPNP_VERSION != 7000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
	namespace schemas {

		CAPNP_DECLARE_SCHEMA(a114d742063a4e99);
		CAPNP_DECLARE_SCHEMA(b0d18e8f06717e4c);
		CAPNP_DECLARE_SCHEMA(82dd810ac250b597);
		enum class Status_82dd810ac250b597 : uint16_t {
			UNKNOWN_ERROR,
			OK,
			FILE_ALREADY_EXISTS,
			FILE_NOT_FOUND,
		};
		CAPNP_DECLARE_ENUM(Status, 82dd810ac250b597);
		CAPNP_DECLARE_SCHEMA(e5e72d2b7cd7fec5);
		CAPNP_DECLARE_SCHEMA(f873416bd0393f8f);
		CAPNP_DECLARE_SCHEMA(d9c0b513aea68cb9);
		CAPNP_DECLARE_SCHEMA(884a9b7330eeb622);
		CAPNP_DECLARE_SCHEMA(b644d1c1e016e640);
		CAPNP_DECLARE_SCHEMA(c70aab0a3ad244f0);
		CAPNP_DECLARE_SCHEMA(fc96101c10fd3e6a);
		CAPNP_DECLARE_SCHEMA(a59056d52bd49445);
		CAPNP_DECLARE_SCHEMA(c9453186afa57335);
		CAPNP_DECLARE_SCHEMA(9996fa7c695afe89);

	}  // namespace schemas
}  // namespace capnp


struct FileManager {
	FileManager() = delete;

#if !CAPNP_LITE
	class Client;
	class Server;
#endif  // !CAPNP_LITE

	struct File;
	typedef ::capnp::schemas::Status_82dd810ac250b597 Status;

	struct HealthCheckParams;
	struct HealthCheckResults;
	struct InsertParams;
	struct InsertResults;
	struct RetrieveParams;
	struct RetrieveResults;
	struct ModifyParams;
	struct ModifyResults;
	struct RemoveParams;
	struct RemoveResults;

#if !CAPNP_LITE
	struct _capnpPrivate {
		CAPNP_DECLARE_INTERFACE_HEADER(a114d742063a4e99)
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
	};
#endif  // !CAPNP_LITE
};

struct FileManager::File {
	File() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(b0d18e8f06717e4c, 0, 3)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::HealthCheckParams {
	HealthCheckParams() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(e5e72d2b7cd7fec5, 0, 0)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::HealthCheckResults {
	HealthCheckResults() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(f873416bd0393f8f, 1, 0)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::InsertParams {
	InsertParams() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(d9c0b513aea68cb9, 0, 1)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::InsertResults {
	InsertResults() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(884a9b7330eeb622, 1, 0)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::RetrieveParams {
	RetrieveParams() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(b644d1c1e016e640, 0, 1)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::RetrieveResults {
	RetrieveResults() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(c70aab0a3ad244f0, 1, 1)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::ModifyParams {
	ModifyParams() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(fc96101c10fd3e6a, 0, 2)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::ModifyResults {
	ModifyResults() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(a59056d52bd49445, 0, 1)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::RemoveParams {
	RemoveParams() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(c9453186afa57335, 0, 1)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

struct FileManager::RemoveResults {
	RemoveResults() = delete;

	class Reader;
	class Builder;
	class Pipeline;

	struct _capnpPrivate {
		CAPNP_DECLARE_STRUCT_HEADER(9996fa7c695afe89, 1, 0)
#if !CAPNP_LITE
			static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
#endif  // !CAPNP_LITE
	};
};

// =======================================================================================

#if !CAPNP_LITE
class FileManager::Client
	: public virtual ::capnp::Capability::Client {
public:
	typedef FileManager Calls;
	typedef FileManager Reads;

	Client(decltype(nullptr));
	explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
	template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
	Client(::kj::Own<_t>&& server);
	template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
	Client(::kj::Promise<_t>&& promise);
	Client(::kj::Exception&& exception);
	Client(Client&) = default;
	Client(Client&&) = default;
	Client& operator=(Client& other);
	Client& operator=(Client&& other);

	::capnp::Request< ::FileManager::HealthCheckParams, ::FileManager::HealthCheckResults> healthCheckRequest(
		::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
	::capnp::Request< ::FileManager::InsertParams, ::FileManager::InsertResults> insertRequest(
		::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
	::capnp::Request< ::FileManager::RetrieveParams, ::FileManager::RetrieveResults> retrieveRequest(
		::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
	::capnp::Request< ::FileManager::ModifyParams, ::FileManager::ModifyResults> modifyRequest(
		::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
	::capnp::Request< ::FileManager::RemoveParams, ::FileManager::RemoveResults> removeRequest(
		::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
	Client() = default;
};

class FileManager::Server
	: public virtual ::capnp::Capability::Server {
public:
	typedef FileManager Serves;

	::kj::Promise<void> dispatchCall(uint64_t interfaceId, uint16_t methodId,
		::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
		override;

protected:
	typedef  ::FileManager::HealthCheckParams HealthCheckParams;
	typedef  ::FileManager::HealthCheckResults HealthCheckResults;
	typedef ::capnp::CallContext<HealthCheckParams, HealthCheckResults> HealthCheckContext;
	virtual ::kj::Promise<void> healthCheck(HealthCheckContext context);
	typedef  ::FileManager::InsertParams InsertParams;
	typedef  ::FileManager::InsertResults InsertResults;
	typedef ::capnp::CallContext<InsertParams, InsertResults> InsertContext;
	virtual ::kj::Promise<void> insert(InsertContext context);
	typedef  ::FileManager::RetrieveParams RetrieveParams;
	typedef  ::FileManager::RetrieveResults RetrieveResults;
	typedef ::capnp::CallContext<RetrieveParams, RetrieveResults> RetrieveContext;
	virtual ::kj::Promise<void> retrieve(RetrieveContext context);
	typedef  ::FileManager::ModifyParams ModifyParams;
	typedef  ::FileManager::ModifyResults ModifyResults;
	typedef ::capnp::CallContext<ModifyParams, ModifyResults> ModifyContext;
	virtual ::kj::Promise<void> modify(ModifyContext context);
	typedef  ::FileManager::RemoveParams RemoveParams;
	typedef  ::FileManager::RemoveResults RemoveResults;
	typedef ::capnp::CallContext<RemoveParams, RemoveResults> RemoveContext;
	virtual ::kj::Promise<void> remove(RemoveContext context);

	inline  ::FileManager::Client thisCap() {
		return ::capnp::Capability::Server::thisCap()
			.template castAs< ::FileManager>();
	}

	::kj::Promise<void> dispatchCallInternal(uint16_t methodId,
		::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class FileManager::File::Reader {
public:
	typedef File Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline bool hasUuid() const;
	inline  ::capnp::Text::Reader getUuid() const;

	inline bool hasName() const;
	inline  ::capnp::Text::Reader getName() const;

	inline bool hasContent() const;
	inline  ::capnp::Data::Reader getContent() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::File::Builder {
public:
	typedef File Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline bool hasUuid();
	inline  ::capnp::Text::Builder getUuid();
	inline void setUuid(::capnp::Text::Reader value);
	inline  ::capnp::Text::Builder initUuid(unsigned int size);
	inline void adoptUuid(::capnp::Orphan< ::capnp::Text>&& value);
	inline ::capnp::Orphan< ::capnp::Text> disownUuid();

	inline bool hasName();
	inline  ::capnp::Text::Builder getName();
	inline void setName(::capnp::Text::Reader value);
	inline  ::capnp::Text::Builder initName(unsigned int size);
	inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
	inline ::capnp::Orphan< ::capnp::Text> disownName();

	inline bool hasContent();
	inline  ::capnp::Data::Builder getContent();
	inline void setContent(::capnp::Data::Reader value);
	inline  ::capnp::Data::Builder initContent(unsigned int size);
	inline void adoptContent(::capnp::Orphan< ::capnp::Data>&& value);
	inline ::capnp::Orphan< ::capnp::Data> disownContent();

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::File::Pipeline {
public:
	typedef File Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::HealthCheckParams::Reader {
public:
	typedef HealthCheckParams Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::HealthCheckParams::Builder {
public:
	typedef HealthCheckParams Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::HealthCheckParams::Pipeline {
public:
	typedef HealthCheckParams Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::HealthCheckResults::Reader {
public:
	typedef HealthCheckResults Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline bool getResult() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::HealthCheckResults::Builder {
public:
	typedef HealthCheckResults Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline bool getResult();
	inline void setResult(bool value);

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::HealthCheckResults::Pipeline {
public:
	typedef HealthCheckResults Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::InsertParams::Reader {
public:
	typedef InsertParams Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline bool hasInput() const;
	inline  ::FileManager::File::Reader getInput() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::InsertParams::Builder {
public:
	typedef InsertParams Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline bool hasInput();
	inline  ::FileManager::File::Builder getInput();
	inline void setInput(::FileManager::File::Reader value);
	inline  ::FileManager::File::Builder initInput();
	inline void adoptInput(::capnp::Orphan< ::FileManager::File>&& value);
	inline ::capnp::Orphan< ::FileManager::File> disownInput();

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::InsertParams::Pipeline {
public:
	typedef InsertParams Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

	inline  ::FileManager::File::Pipeline getInput();
private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::InsertResults::Reader {
public:
	typedef InsertResults Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline  ::FileManager::Status getStatus() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::InsertResults::Builder {
public:
	typedef InsertResults Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline  ::FileManager::Status getStatus();
	inline void setStatus(::FileManager::Status value);

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::InsertResults::Pipeline {
public:
	typedef InsertResults Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::RetrieveParams::Reader {
public:
	typedef RetrieveParams Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline bool hasUuid() const;
	inline  ::capnp::Text::Reader getUuid() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::RetrieveParams::Builder {
public:
	typedef RetrieveParams Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline bool hasUuid();
	inline  ::capnp::Text::Builder getUuid();
	inline void setUuid(::capnp::Text::Reader value);
	inline  ::capnp::Text::Builder initUuid(unsigned int size);
	inline void adoptUuid(::capnp::Orphan< ::capnp::Text>&& value);
	inline ::capnp::Orphan< ::capnp::Text> disownUuid();

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::RetrieveParams::Pipeline {
public:
	typedef RetrieveParams Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::RetrieveResults::Reader {
public:
	typedef RetrieveResults Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline  ::FileManager::Status getStatus() const;

	inline bool hasFile() const;
	inline  ::FileManager::File::Reader getFile() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::RetrieveResults::Builder {
public:
	typedef RetrieveResults Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline  ::FileManager::Status getStatus();
	inline void setStatus(::FileManager::Status value);

	inline bool hasFile();
	inline  ::FileManager::File::Builder getFile();
	inline void setFile(::FileManager::File::Reader value);
	inline  ::FileManager::File::Builder initFile();
	inline void adoptFile(::capnp::Orphan< ::FileManager::File>&& value);
	inline ::capnp::Orphan< ::FileManager::File> disownFile();

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::RetrieveResults::Pipeline {
public:
	typedef RetrieveResults Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

	inline  ::FileManager::File::Pipeline getFile();
private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::ModifyParams::Reader {
public:
	typedef ModifyParams Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline bool hasUuid() const;
	inline  ::capnp::Text::Reader getUuid() const;

	inline bool hasData() const;
	inline  ::capnp::Data::Reader getData() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::ModifyParams::Builder {
public:
	typedef ModifyParams Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline bool hasUuid();
	inline  ::capnp::Text::Builder getUuid();
	inline void setUuid(::capnp::Text::Reader value);
	inline  ::capnp::Text::Builder initUuid(unsigned int size);
	inline void adoptUuid(::capnp::Orphan< ::capnp::Text>&& value);
	inline ::capnp::Orphan< ::capnp::Text> disownUuid();

	inline bool hasData();
	inline  ::capnp::Data::Builder getData();
	inline void setData(::capnp::Data::Reader value);
	inline  ::capnp::Data::Builder initData(unsigned int size);
	inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
	inline ::capnp::Orphan< ::capnp::Data> disownData();

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::ModifyParams::Pipeline {
public:
	typedef ModifyParams Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::ModifyResults::Reader {
public:
	typedef ModifyResults Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline bool hasFile() const;
	inline  ::FileManager::File::Reader getFile() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::ModifyResults::Builder {
public:
	typedef ModifyResults Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline bool hasFile();
	inline  ::FileManager::File::Builder getFile();
	inline void setFile(::FileManager::File::Reader value);
	inline  ::FileManager::File::Builder initFile();
	inline void adoptFile(::capnp::Orphan< ::FileManager::File>&& value);
	inline ::capnp::Orphan< ::FileManager::File> disownFile();

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::ModifyResults::Pipeline {
public:
	typedef ModifyResults Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

	inline  ::FileManager::File::Pipeline getFile();
private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::RemoveParams::Reader {
public:
	typedef RemoveParams Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline bool hasUuid() const;
	inline  ::capnp::Text::Reader getUuid() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::RemoveParams::Builder {
public:
	typedef RemoveParams Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline bool hasUuid();
	inline  ::capnp::Text::Builder getUuid();
	inline void setUuid(::capnp::Text::Reader value);
	inline  ::capnp::Text::Builder initUuid(unsigned int size);
	inline void adoptUuid(::capnp::Orphan< ::capnp::Text>&& value);
	inline ::capnp::Orphan< ::capnp::Text> disownUuid();

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::RemoveParams::Pipeline {
public:
	typedef RemoveParams Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class FileManager::RemoveResults::Reader {
public:
	typedef RemoveResults Reads;

	Reader() = default;
	inline explicit Reader(::capnp::_::StructReader base) : _reader(base) {}

	inline ::capnp::MessageSize totalSize() const {
		return _reader.totalSize().asPublic();
	}

#if !CAPNP_LITE
	inline ::kj::StringTree toString() const {
		return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
	}
#endif  // !CAPNP_LITE

	inline  ::FileManager::Status getStatus() const;

private:
	::capnp::_::StructReader _reader;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::List;
	friend class ::capnp::MessageBuilder;
	friend class ::capnp::Orphanage;
};

class FileManager::RemoveResults::Builder {
public:
	typedef RemoveResults Builds;

	Builder() = delete;  // Deleted to discourage incorrect usage.
						 // You can explicitly initialize to nullptr instead.
	inline Builder(decltype(nullptr)) {}
	inline explicit Builder(::capnp::_::StructBuilder base) : _builder(base) {}
	inline operator Reader() const { return Reader(_builder.asReader()); }
	inline Reader asReader() const { return *this; }

	inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
	inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

	inline  ::FileManager::Status getStatus();
	inline void setStatus(::FileManager::Status value);

private:
	::capnp::_::StructBuilder _builder;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
	friend class ::capnp::Orphanage;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class FileManager::RemoveResults::Pipeline {
public:
	typedef RemoveResults Pipelines;

	inline Pipeline(decltype(nullptr)) : _typeless(nullptr) {}
	inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
		: _typeless(kj::mv(typeless)) {}

private:
	::capnp::AnyPointer::Pipeline _typeless;
	friend class ::capnp::PipelineHook;
	template <typename, ::capnp::Kind>
	friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

#if !CAPNP_LITE
inline FileManager::Client::Client(decltype(nullptr))
	: ::capnp::Capability::Client(nullptr) {}
inline FileManager::Client::Client(
	::kj::Own< ::capnp::ClientHook>&& hook)
	: ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline FileManager::Client::Client(::kj::Own<_t>&& server)
	: ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline FileManager::Client::Client(::kj::Promise<_t>&& promise)
	: ::capnp::Capability::Client(::kj::mv(promise)) {}
inline FileManager::Client::Client(::kj::Exception&& exception)
	: ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::FileManager::Client& FileManager::Client::operator=(Client& other) {
	::capnp::Capability::Client::operator=(other);
	return *this;
}
inline  ::FileManager::Client& FileManager::Client::operator=(Client&& other) {
	::capnp::Capability::Client::operator=(kj::mv(other));
	return *this;
}

#endif  // !CAPNP_LITE
inline bool FileManager::File::Reader::hasUuid() const {
	return !_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::File::Builder::hasUuid() {
	return !_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader FileManager::File::Reader::getUuid() const {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder FileManager::File::Builder::getUuid() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FileManager::File::Builder::setUuid(::capnp::Text::Reader value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder FileManager::File::Builder::initUuid(unsigned int size) {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FileManager::File::Builder::adoptUuid(
	::capnp::Orphan< ::capnp::Text>&& value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> FileManager::File::Builder::disownUuid() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FileManager::File::Reader::hasName() const {
	return !_reader.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::File::Builder::hasName() {
	return !_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader FileManager::File::Reader::getName() const {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder FileManager::File::Builder::getName() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FileManager::File::Builder::setName(::capnp::Text::Reader value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder FileManager::File::Builder::initName(unsigned int size) {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void FileManager::File::Builder::adoptName(
	::capnp::Orphan< ::capnp::Text>&& value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> FileManager::File::Builder::disownName() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool FileManager::File::Reader::hasContent() const {
	return !_reader.getPointerField(
		::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::File::Builder::hasContent() {
	return !_builder.getPointerField(
		::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader FileManager::File::Reader::getContent() const {
	return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
		::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder FileManager::File::Builder::getContent() {
	return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
		::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void FileManager::File::Builder::setContent(::capnp::Data::Reader value) {
	::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
		::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder FileManager::File::Builder::initContent(unsigned int size) {
	return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
		::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void FileManager::File::Builder::adoptContent(
	::capnp::Orphan< ::capnp::Data>&& value) {
	::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
		::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> FileManager::File::Builder::disownContent() {
	return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
		::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool FileManager::HealthCheckResults::Reader::getResult() const {
	return _reader.getDataField<bool>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool FileManager::HealthCheckResults::Builder::getResult() {
	return _builder.getDataField<bool>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FileManager::HealthCheckResults::Builder::setResult(bool value) {
	_builder.setDataField<bool>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FileManager::InsertParams::Reader::hasInput() const {
	return !_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::InsertParams::Builder::hasInput() {
	return !_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::FileManager::File::Reader FileManager::InsertParams::Reader::getInput() const {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::get(_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::FileManager::File::Builder FileManager::InsertParams::Builder::getInput() {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::get(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::FileManager::File::Pipeline FileManager::InsertParams::Pipeline::getInput() {
	return  ::FileManager::File::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FileManager::InsertParams::Builder::setInput(::FileManager::File::Reader value) {
	::capnp::_::PointerHelpers< ::FileManager::File>::set(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::FileManager::File::Builder FileManager::InsertParams::Builder::initInput() {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::init(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FileManager::InsertParams::Builder::adoptInput(
	::capnp::Orphan< ::FileManager::File>&& value) {
	::capnp::_::PointerHelpers< ::FileManager::File>::adopt(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::FileManager::File> FileManager::InsertParams::Builder::disownInput() {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::disown(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::FileManager::Status FileManager::InsertResults::Reader::getStatus() const {
	return _reader.getDataField< ::FileManager::Status>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::FileManager::Status FileManager::InsertResults::Builder::getStatus() {
	return _builder.getDataField< ::FileManager::Status>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FileManager::InsertResults::Builder::setStatus(::FileManager::Status value) {
	_builder.setDataField< ::FileManager::Status>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FileManager::RetrieveParams::Reader::hasUuid() const {
	return !_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::RetrieveParams::Builder::hasUuid() {
	return !_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader FileManager::RetrieveParams::Reader::getUuid() const {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder FileManager::RetrieveParams::Builder::getUuid() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FileManager::RetrieveParams::Builder::setUuid(::capnp::Text::Reader value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder FileManager::RetrieveParams::Builder::initUuid(unsigned int size) {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FileManager::RetrieveParams::Builder::adoptUuid(
	::capnp::Orphan< ::capnp::Text>&& value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> FileManager::RetrieveParams::Builder::disownUuid() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::FileManager::Status FileManager::RetrieveResults::Reader::getStatus() const {
	return _reader.getDataField< ::FileManager::Status>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::FileManager::Status FileManager::RetrieveResults::Builder::getStatus() {
	return _builder.getDataField< ::FileManager::Status>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FileManager::RetrieveResults::Builder::setStatus(::FileManager::Status value) {
	_builder.setDataField< ::FileManager::Status>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool FileManager::RetrieveResults::Reader::hasFile() const {
	return !_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::RetrieveResults::Builder::hasFile() {
	return !_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::FileManager::File::Reader FileManager::RetrieveResults::Reader::getFile() const {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::get(_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::FileManager::File::Builder FileManager::RetrieveResults::Builder::getFile() {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::get(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::FileManager::File::Pipeline FileManager::RetrieveResults::Pipeline::getFile() {
	return  ::FileManager::File::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FileManager::RetrieveResults::Builder::setFile(::FileManager::File::Reader value) {
	::capnp::_::PointerHelpers< ::FileManager::File>::set(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::FileManager::File::Builder FileManager::RetrieveResults::Builder::initFile() {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::init(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FileManager::RetrieveResults::Builder::adoptFile(
	::capnp::Orphan< ::FileManager::File>&& value) {
	::capnp::_::PointerHelpers< ::FileManager::File>::adopt(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::FileManager::File> FileManager::RetrieveResults::Builder::disownFile() {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::disown(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FileManager::ModifyParams::Reader::hasUuid() const {
	return !_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::ModifyParams::Builder::hasUuid() {
	return !_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader FileManager::ModifyParams::Reader::getUuid() const {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder FileManager::ModifyParams::Builder::getUuid() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FileManager::ModifyParams::Builder::setUuid(::capnp::Text::Reader value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder FileManager::ModifyParams::Builder::initUuid(unsigned int size) {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FileManager::ModifyParams::Builder::adoptUuid(
	::capnp::Orphan< ::capnp::Text>&& value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> FileManager::ModifyParams::Builder::disownUuid() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FileManager::ModifyParams::Reader::hasData() const {
	return !_reader.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::ModifyParams::Builder::hasData() {
	return !_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader FileManager::ModifyParams::Reader::getData() const {
	return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder FileManager::ModifyParams::Builder::getData() {
	return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void FileManager::ModifyParams::Builder::setData(::capnp::Data::Reader value) {
	::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder FileManager::ModifyParams::Builder::initData(unsigned int size) {
	return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void FileManager::ModifyParams::Builder::adoptData(
	::capnp::Orphan< ::capnp::Data>&& value) {
	::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> FileManager::ModifyParams::Builder::disownData() {
	return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
		::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool FileManager::ModifyResults::Reader::hasFile() const {
	return !_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::ModifyResults::Builder::hasFile() {
	return !_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::FileManager::File::Reader FileManager::ModifyResults::Reader::getFile() const {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::get(_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::FileManager::File::Builder FileManager::ModifyResults::Builder::getFile() {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::get(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::FileManager::File::Pipeline FileManager::ModifyResults::Pipeline::getFile() {
	return  ::FileManager::File::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void FileManager::ModifyResults::Builder::setFile(::FileManager::File::Reader value) {
	::capnp::_::PointerHelpers< ::FileManager::File>::set(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::FileManager::File::Builder FileManager::ModifyResults::Builder::initFile() {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::init(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FileManager::ModifyResults::Builder::adoptFile(
	::capnp::Orphan< ::FileManager::File>&& value) {
	::capnp::_::PointerHelpers< ::FileManager::File>::adopt(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::FileManager::File> FileManager::ModifyResults::Builder::disownFile() {
	return ::capnp::_::PointerHelpers< ::FileManager::File>::disown(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool FileManager::RemoveParams::Reader::hasUuid() const {
	return !_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool FileManager::RemoveParams::Builder::hasUuid() {
	return !_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader FileManager::RemoveParams::Reader::getUuid() const {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder FileManager::RemoveParams::Builder::getUuid() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void FileManager::RemoveParams::Builder::setUuid(::capnp::Text::Reader value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder FileManager::RemoveParams::Builder::initUuid(unsigned int size) {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void FileManager::RemoveParams::Builder::adoptUuid(
	::capnp::Orphan< ::capnp::Text>&& value) {
	::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> FileManager::RemoveParams::Builder::disownUuid() {
	return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
		::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::FileManager::Status FileManager::RemoveResults::Reader::getStatus() const {
	return _reader.getDataField< ::FileManager::Status>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::FileManager::Status FileManager::RemoveResults::Builder::getStatus() {
	return _builder.getDataField< ::FileManager::Status>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void FileManager::RemoveResults::Builder::setStatus(::FileManager::Status value) {
	_builder.setDataField< ::FileManager::Status>(
		::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

